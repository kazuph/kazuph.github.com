セキュリティ 〜概念編〜
18:00 4 Sep 2014

Kazuhiro Homma
Engineer, Photosynth

kazu.homma@gmail.com
https://github.com/kauzph
@kazuph

* 全講座

- 概念編(2014/09/09)
- アルゴリズム編
- 組み込み機器編
- BLEモジュール編

* Agenda

- セキュリティが高い状態とは？
- 暗号化
- 鍵の共有
- 電子署名

* セキュリティが高い状態とは？

* セキュリティが高い状態とは？

- 情報が漏れても第３者が解読できない
→通信傍受、データベースのデータ漏えい

- 自分が伝えたい人のみに情報を伝えられる
→第三者によるなりすまし

* セキュリティが高い状態とは？

- 情報が漏れても第３者が解読できない
→通信傍受、データベースのデータ漏えい
→暗号化、ハッシュ化

- 自分が伝えたい人のみに情報を伝えられる
→第三者によるなりすまし
→なりすまし防止(電子署名)

* 暗号化

* 暗号化する意味

- 個人・法人の財産を守る
→個人情報、社外秘流出による損害を防ぐ

* 確認問題: パスワードを暗号化

- パスワードをデータベースに保存するときに暗号化はしますか？

* 確認問題: パスワードを暗号化…？

- パスワードは本人のみが知っていればいい
- サービス運営業者は別のパスワード自体に興味はない（はず）
- DBに入れるのは暗号化、ではなくハッシュ化したパスワード
- ユーザーが入力したパスワードをハッシュ化して比較すれば本人確認は済む
- 「パスワードリマインダしたらパスワードが平文で送られてきた…」

* 確認問題: パスワードを暗号化…？

暗号化している場合に、データ流出しかつ復号できた場合には第三者が自由にサービスを使えるようになったり、他のパスワードが同じサービスへもログインできてしまう可能性がある。

→ 例）Twitterのパスワードが漏れてFacebookもログインされてしまう

なのでサービス運営側はパスワードを暗号化してはならない。
するのはパスワードのハッシュ化。

* ハッシュ化？

- 元に戻せない状態で文字列の変換を行うこと
- 同じデータからは同じハッシュ値が生成される
→大きなデータだったとしても、同じ文字数のハッシュが返る
→データの一致確認に使える

* 試してみる

同じ文字からは同じハッシュ値

    $ perl -MDigest::SHA -E 'say Digest::SHA::sha256_hex("hoge");'
    ecb666d778725ec97307044d642bf4d160aabb76f56c0069c71ea25b1e926825

    $ perl -MDigest::SHA -E 'say Digest::SHA::sha256_hex("hoge");'
    ecb666d778725ec97307044d642bf4d160aabb76f56c0069c71ea25b1e926825

元データの文字列に関係なく同じ長さのハッシュ値が返る

    $ perl -MDigest::SHA -E 'say Digest::SHA::sha256_hex("hoge fuga");'
    42e322a71d477ae1b28616ae8afe236000e99f150a31261553fc368efcc746dd

    $ perl -MDigest::SHA -E 'say Digest::SHA::sha256_hex("42e322a...");'
    69f357b5c0731e162196a838bc14d2ab8404a4749ecf75bd26dd1cc6240d9cfa

* で、本当にハッシュ化すると安全なの？

うっ、続きはこちらで…

.link http://www.atmarkit.co.jp/fsecurity/special/165pswd/01.html ハッシュとソルト、ストレッチングを正しく理解する 本当は怖いパスワードの話



* ここで言葉の定義の確認

- 平文
普通に読める文字。暗号化されていない文字列。

- 暗号化
第三者に通信内容を知られない目的で、平文を特別な知識なしでは読めないような文字列に変換することである

- 暗号文
暗号化された文字列

- 復号
暗号化された文字列を元の平文に戻すこと

* ここで言葉の定義の確認

- ハッシュ化
意味のない文字列に変換しかつ復号できない (ただし解読手法は存在する)

- 解読
第三者が平文を得る目的で暗号文を解析すること

より詳しくは

.link http://ja.wikipedia.org/wiki/%E6%9A%97%E5%8F%B7 Wikipedia

* 復号（解読）のコスト

- 方法を知っている人→低
- 方法を知らない人→極大！

解読方法が存在したとしても、現実的なコストでなければ悪意のある人は解読行為を行わない、行っても意味が無い

* 復号（解読）のコスト

- ユーザビリティに影響が出る場合
→マシンスペックが低い(組み込み用デバイスなど)
→操作手順が増える
    →このためユーザビリティとセキュリティはトレードオフになる場合が多い

* 暗号化を試してみる

カエサル暗号を使う
（アルファベットを何文字かずらすだけ）

    #!/usr/bin/env ruby
    class String
    def encrypt; tr 'a-zA-Z', 'n-za-mN-ZA-M' end
    end
    puts ARGV[0].encrypt
    puts ARGV[0].encrypt.decrypt

* カエサル暗号の問題点

- アルファベットは全部で26文字しかないので25通り調べて意味のある文字列が出てきたらそれだけで解読できる
→26文字 - 0文字もずらさない場合の数 = 25

- コンピュータなら一瞬のできごと
→X文字ずらしてることがバレたらあとは全部筒抜け

- 手法がバレたら終わり

* 解読に対する対策
- 手法がバレたら終わりだとしたら、無限に暗号化の手法を生み出せば良い？
→普通に考えて現実的じゃない

- 昔の人は考えた
→手法は単一だけど、暗号に使う"鍵"が推測されなければいい
→カエサル暗号の場合はずらず文字数X(25通り)

* 鍵の組合せが何通りもあること

大文字含む英数字が鍵だった場合

10文字だったとしても解読するために713342911662882601通り調べる必要がある。

記号も入れば…

    $ ruby -e 'p [*"a".."z"].size'
    26通り
    $ ruby -e "p [*1..9, *'A'..'Z', *'a'..'z'].size"
    61通り
    $ ruby -e "p [*1..9, *'A'..'Z', *'a'..'z'].size ** 2"
    3721通り
    $ ruby -e "p [*1..9, *'A'..'Z', *'a'..'z'].size ** 3"
    226981通り
    $ ruby -e "p [*1..9, *'A'..'Z', *'a'..'z'].size ** 10"
    713342911662882601通り
    $ ruby -e "p [*1..9, *'A'..'Z', *'a'..'z'].size ** 32"
    1350687001332003958728623852374735172807518011483204347521通り

* 鍵を用いる暗号化を試してみる

.html ./html/criypt.html

.link http://docs.ruby-lang.org/ja/1.9.3/library/openssl.html#references 暗号化アルゴリズム一覧(Ruby)

* 鍵を用いる暗号化を試してみる

    $ ruby crypt.rb hoge
    暗号文:         fgmZB1F4HKiI9vUOPO2utA==
    復号した平文:   hoge

    $ ruby crypt.rb fuga
    暗号文:         bBu9p6BXKdxsfiKb1ocrkg==
    復号した平文:   fuga

ランダムな暗号文が元の平文に戻っていることがわかる

* 暗号化まとめ

暗号化では安全な手法を用いて現実時間で推測されない鍵を使用する

* 鍵の共有

* 鍵の共有について

- 鍵が推測されなかったとしても鍵がバレたらそれで終わり
→鍵の受け渡しにメールやIMなどを使っていたためパケット解析された
→鍵の受け渡しに使ったUSBメモリが盗まれた
→書いていた紙を盗まれた…

* 共通鍵暗号方式

AESとか使っていたとしたら、事前に送信者と受信者の間で鍵を共有する必要がある

安全に鍵の受け渡しができる方法あれば良いが、そうでないならこの手法は解読コストなしに解読されてしまう

* 公開鍵暗号方式

そこで考案されたのが、公開鍵と秘密鍵をペアで生成しバレてもいい鍵を公開するという方法

* なぜ鍵を公開してもいいのか？

- 公開鍵で暗号化したものは公開鍵で復号できない
- 公開鍵で暗号化したものは秘密鍵を持っている人のみ復号できる
- 秘密鍵は転送する必要がないので漏洩リスクが極端に低くなる

* 暗号化の単一方向性

- 公開鍵で暗号化したものは公開鍵で復号できない、が担保できないと成立しない暗号化手法
→考案された手法→RSA、DSA、ECDSA
→詳しくは次回以降

* 電子署名

* 本当にこの人にデータを送っていいの？問題

- これも公開鍵暗号方式を応用できる
- 秘密鍵を持っている人の身元を識別できるようになる
→逆は無理なはず、原理的に

- なぜハッシュを使うのかってのは前半の説明を参照のこと

* 電子署名

.image http://i.gyazo.com/80c72b3a7c78c7b0ba1c8be2a383dd07.png

* SSHの場合双方向の識別はどうしているか？

- サーバーの識別はIPを信頼するしかない
→公開鍵が置いてあることは原理的には信頼できない

- サーバーへの接続者が関係のない第三者でないことの証明は秘密鍵で行っている


* クライアント側からのデータ転送は？
- 秘密鍵で暗号化？→爆！公開鍵で復号できる
- 公開鍵暗号方式で信頼できるのはサーバーからクライアントへの送信のみ
→一時的に共通鍵をサーバー側でつくって、クライアントへ送れば安全に双方向通信できる

* クライアント側からのデータ転送は？
.image http://i.gyazo.com/b24bb525bee22eebc8e1f9f908927141.png

* クライアント側からのデータ転送は？
.image http://i.gyazo.com/0502bd9c3d9a896d03c2dbe8d392bd31.png

* 概念編まとめ
* 概念編まとめ

- 暗号化では安全な手法を用いて現実時間で推測されない鍵を使用する
- ハッシュ化、共通鍵暗号方式、公開鍵暗号方式を組み合わせると安全に双方向通信できる

.html ./html/css.html
